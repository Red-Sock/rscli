package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Red-Sock/rscli/internal/io/folder"
	mm_project "github.com/Red-Sock/rscli/plugins/project"
	"github.com/Red-Sock/rscli/plugins/project/config"
	"github.com/gojuno/minimock/v3"
)

// IProjectMock implements project.IProject
type IProjectMock struct {
	t minimock.Tester

	funcGetConfig          func() (cp1 *config.Config)
	inspectFuncGetConfig   func()
	afterGetConfigCounter  uint64
	beforeGetConfigCounter uint64
	GetConfigMock          mIProjectMockGetConfig

	funcGetFolder          func() (fp1 *folder.Folder)
	inspectFuncGetFolder   func()
	afterGetFolderCounter  uint64
	beforeGetFolderCounter uint64
	GetFolderMock          mIProjectMockGetFolder

	funcGetName          func() (s1 string)
	inspectFuncGetName   func()
	afterGetNameCounter  uint64
	beforeGetNameCounter uint64
	GetNameMock          mIProjectMockGetName

	funcGetProjectPath          func() (s1 string)
	inspectFuncGetProjectPath   func()
	afterGetProjectPathCounter  uint64
	beforeGetProjectPathCounter uint64
	GetProjectPathMock          mIProjectMockGetProjectPath

	funcGetShortName          func() (s1 string)
	inspectFuncGetShortName   func()
	afterGetShortNameCounter  uint64
	beforeGetShortNameCounter uint64
	GetShortNameMock          mIProjectMockGetShortName

	funcGetType          func() (t1 mm_project.Type)
	inspectFuncGetType   func()
	afterGetTypeCounter  uint64
	beforeGetTypeCounter uint64
	GetTypeMock          mIProjectMockGetType
}

// NewIProjectMock returns a mock for project.IProject
func NewIProjectMock(t minimock.Tester) *IProjectMock {
	m := &IProjectMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetConfigMock = mIProjectMockGetConfig{mock: m}

	m.GetFolderMock = mIProjectMockGetFolder{mock: m}

	m.GetNameMock = mIProjectMockGetName{mock: m}

	m.GetProjectPathMock = mIProjectMockGetProjectPath{mock: m}

	m.GetShortNameMock = mIProjectMockGetShortName{mock: m}

	m.GetTypeMock = mIProjectMockGetType{mock: m}

	return m
}

type mIProjectMockGetConfig struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetConfigExpectation
	expectations       []*IProjectMockGetConfigExpectation
}

// IProjectMockGetConfigExpectation specifies expectation struct of the IProject.GetConfig
type IProjectMockGetConfigExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetConfigResults
	Counter uint64
}

// IProjectMockGetConfigResults contains results of the IProject.GetConfig
type IProjectMockGetConfigResults struct {
	cp1 *config.Config
}

// Expect sets up expected params for IProject.GetConfig
func (mmGetConfig *mIProjectMockGetConfig) Expect() *mIProjectMockGetConfig {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("IProjectMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &IProjectMockGetConfigExpectation{}
	}

	return mmGetConfig
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetConfig
func (mmGetConfig *mIProjectMockGetConfig) Inspect(f func()) *mIProjectMockGetConfig {
	if mmGetConfig.mock.inspectFuncGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetConfig")
	}

	mmGetConfig.mock.inspectFuncGetConfig = f

	return mmGetConfig
}

// Return sets up results that will be returned by IProject.GetConfig
func (mmGetConfig *mIProjectMockGetConfig) Return(cp1 *config.Config) *IProjectMock {
	if mmGetConfig.mock.funcGetConfig != nil {
		mmGetConfig.mock.t.Fatalf("IProjectMock.GetConfig mock is already set by Set")
	}

	if mmGetConfig.defaultExpectation == nil {
		mmGetConfig.defaultExpectation = &IProjectMockGetConfigExpectation{mock: mmGetConfig.mock}
	}
	mmGetConfig.defaultExpectation.results = &IProjectMockGetConfigResults{cp1}
	return mmGetConfig.mock
}

// Set uses given function f to mock the IProject.GetConfig method
func (mmGetConfig *mIProjectMockGetConfig) Set(f func() (cp1 *config.Config)) *IProjectMock {
	if mmGetConfig.defaultExpectation != nil {
		mmGetConfig.mock.t.Fatalf("Default expectation is already set for the IProject.GetConfig method")
	}

	if len(mmGetConfig.expectations) > 0 {
		mmGetConfig.mock.t.Fatalf("Some expectations are already set for the IProject.GetConfig method")
	}

	mmGetConfig.mock.funcGetConfig = f
	return mmGetConfig.mock
}

// GetConfig implements project.IProject
func (mmGetConfig *IProjectMock) GetConfig() (cp1 *config.Config) {
	mm_atomic.AddUint64(&mmGetConfig.beforeGetConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmGetConfig.afterGetConfigCounter, 1)

	if mmGetConfig.inspectFuncGetConfig != nil {
		mmGetConfig.inspectFuncGetConfig()
	}

	if mmGetConfig.GetConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetConfig.GetConfigMock.defaultExpectation.Counter, 1)

		mm_results := mmGetConfig.GetConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmGetConfig.t.Fatal("No results are set for the IProjectMock.GetConfig")
		}
		return (*mm_results).cp1
	}
	if mmGetConfig.funcGetConfig != nil {
		return mmGetConfig.funcGetConfig()
	}
	mmGetConfig.t.Fatalf("Unexpected call to IProjectMock.GetConfig.")
	return
}

// GetConfigAfterCounter returns a count of finished IProjectMock.GetConfig invocations
func (mmGetConfig *IProjectMock) GetConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.afterGetConfigCounter)
}

// GetConfigBeforeCounter returns a count of IProjectMock.GetConfig invocations
func (mmGetConfig *IProjectMock) GetConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetConfig.beforeGetConfigCounter)
}

// MinimockGetConfigDone returns true if the count of the GetConfig invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetConfigDone() bool {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetConfigInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetConfigInspect() {
	for _, e := range m.GetConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetConfig")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetConfigMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetConfig")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetConfig != nil && mm_atomic.LoadUint64(&m.afterGetConfigCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetConfig")
	}
}

type mIProjectMockGetFolder struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetFolderExpectation
	expectations       []*IProjectMockGetFolderExpectation
}

// IProjectMockGetFolderExpectation specifies expectation struct of the IProject.GetFolder
type IProjectMockGetFolderExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetFolderResults
	Counter uint64
}

// IProjectMockGetFolderResults contains results of the IProject.GetFolder
type IProjectMockGetFolderResults struct {
	fp1 *folder.Folder
}

// Expect sets up expected params for IProject.GetFolder
func (mmGetFolder *mIProjectMockGetFolder) Expect() *mIProjectMockGetFolder {
	if mmGetFolder.mock.funcGetFolder != nil {
		mmGetFolder.mock.t.Fatalf("IProjectMock.GetFolder mock is already set by Set")
	}

	if mmGetFolder.defaultExpectation == nil {
		mmGetFolder.defaultExpectation = &IProjectMockGetFolderExpectation{}
	}

	return mmGetFolder
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetFolder
func (mmGetFolder *mIProjectMockGetFolder) Inspect(f func()) *mIProjectMockGetFolder {
	if mmGetFolder.mock.inspectFuncGetFolder != nil {
		mmGetFolder.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetFolder")
	}

	mmGetFolder.mock.inspectFuncGetFolder = f

	return mmGetFolder
}

// Return sets up results that will be returned by IProject.GetFolder
func (mmGetFolder *mIProjectMockGetFolder) Return(fp1 *folder.Folder) *IProjectMock {
	if mmGetFolder.mock.funcGetFolder != nil {
		mmGetFolder.mock.t.Fatalf("IProjectMock.GetFolder mock is already set by Set")
	}

	if mmGetFolder.defaultExpectation == nil {
		mmGetFolder.defaultExpectation = &IProjectMockGetFolderExpectation{mock: mmGetFolder.mock}
	}
	mmGetFolder.defaultExpectation.results = &IProjectMockGetFolderResults{fp1}
	return mmGetFolder.mock
}

// Set uses given function f to mock the IProject.GetFolder method
func (mmGetFolder *mIProjectMockGetFolder) Set(f func() (fp1 *folder.Folder)) *IProjectMock {
	if mmGetFolder.defaultExpectation != nil {
		mmGetFolder.mock.t.Fatalf("Default expectation is already set for the IProject.GetFolder method")
	}

	if len(mmGetFolder.expectations) > 0 {
		mmGetFolder.mock.t.Fatalf("Some expectations are already set for the IProject.GetFolder method")
	}

	mmGetFolder.mock.funcGetFolder = f
	return mmGetFolder.mock
}

// GetFolder implements project.IProject
func (mmGetFolder *IProjectMock) GetFolder() (fp1 *folder.Folder) {
	mm_atomic.AddUint64(&mmGetFolder.beforeGetFolderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFolder.afterGetFolderCounter, 1)

	if mmGetFolder.inspectFuncGetFolder != nil {
		mmGetFolder.inspectFuncGetFolder()
	}

	if mmGetFolder.GetFolderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFolder.GetFolderMock.defaultExpectation.Counter, 1)

		mm_results := mmGetFolder.GetFolderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFolder.t.Fatal("No results are set for the IProjectMock.GetFolder")
		}
		return (*mm_results).fp1
	}
	if mmGetFolder.funcGetFolder != nil {
		return mmGetFolder.funcGetFolder()
	}
	mmGetFolder.t.Fatalf("Unexpected call to IProjectMock.GetFolder.")
	return
}

// GetFolderAfterCounter returns a count of finished IProjectMock.GetFolder invocations
func (mmGetFolder *IProjectMock) GetFolderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFolder.afterGetFolderCounter)
}

// GetFolderBeforeCounter returns a count of IProjectMock.GetFolder invocations
func (mmGetFolder *IProjectMock) GetFolderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFolder.beforeGetFolderCounter)
}

// MinimockGetFolderDone returns true if the count of the GetFolder invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetFolderDone() bool {
	for _, e := range m.GetFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFolderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFolder != nil && mm_atomic.LoadUint64(&m.afterGetFolderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFolderInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetFolderInspect() {
	for _, e := range m.GetFolderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetFolder")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFolderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFolderCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetFolder")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFolder != nil && mm_atomic.LoadUint64(&m.afterGetFolderCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetFolder")
	}
}

type mIProjectMockGetName struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetNameExpectation
	expectations       []*IProjectMockGetNameExpectation
}

// IProjectMockGetNameExpectation specifies expectation struct of the IProject.GetName
type IProjectMockGetNameExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetNameResults
	Counter uint64
}

// IProjectMockGetNameResults contains results of the IProject.GetName
type IProjectMockGetNameResults struct {
	s1 string
}

// Expect sets up expected params for IProject.GetName
func (mmGetName *mIProjectMockGetName) Expect() *mIProjectMockGetName {
	if mmGetName.mock.funcGetName != nil {
		mmGetName.mock.t.Fatalf("IProjectMock.GetName mock is already set by Set")
	}

	if mmGetName.defaultExpectation == nil {
		mmGetName.defaultExpectation = &IProjectMockGetNameExpectation{}
	}

	return mmGetName
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetName
func (mmGetName *mIProjectMockGetName) Inspect(f func()) *mIProjectMockGetName {
	if mmGetName.mock.inspectFuncGetName != nil {
		mmGetName.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetName")
	}

	mmGetName.mock.inspectFuncGetName = f

	return mmGetName
}

// Return sets up results that will be returned by IProject.GetName
func (mmGetName *mIProjectMockGetName) Return(s1 string) *IProjectMock {
	if mmGetName.mock.funcGetName != nil {
		mmGetName.mock.t.Fatalf("IProjectMock.GetName mock is already set by Set")
	}

	if mmGetName.defaultExpectation == nil {
		mmGetName.defaultExpectation = &IProjectMockGetNameExpectation{mock: mmGetName.mock}
	}
	mmGetName.defaultExpectation.results = &IProjectMockGetNameResults{s1}
	return mmGetName.mock
}

// Set uses given function f to mock the IProject.GetName method
func (mmGetName *mIProjectMockGetName) Set(f func() (s1 string)) *IProjectMock {
	if mmGetName.defaultExpectation != nil {
		mmGetName.mock.t.Fatalf("Default expectation is already set for the IProject.GetName method")
	}

	if len(mmGetName.expectations) > 0 {
		mmGetName.mock.t.Fatalf("Some expectations are already set for the IProject.GetName method")
	}

	mmGetName.mock.funcGetName = f
	return mmGetName.mock
}

// GetName implements project.IProject
func (mmGetName *IProjectMock) GetName() (s1 string) {
	mm_atomic.AddUint64(&mmGetName.beforeGetNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetName.afterGetNameCounter, 1)

	if mmGetName.inspectFuncGetName != nil {
		mmGetName.inspectFuncGetName()
	}

	if mmGetName.GetNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetName.GetNameMock.defaultExpectation.Counter, 1)

		mm_results := mmGetName.GetNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetName.t.Fatal("No results are set for the IProjectMock.GetName")
		}
		return (*mm_results).s1
	}
	if mmGetName.funcGetName != nil {
		return mmGetName.funcGetName()
	}
	mmGetName.t.Fatalf("Unexpected call to IProjectMock.GetName.")
	return
}

// GetNameAfterCounter returns a count of finished IProjectMock.GetName invocations
func (mmGetName *IProjectMock) GetNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetName.afterGetNameCounter)
}

// GetNameBeforeCounter returns a count of IProjectMock.GetName invocations
func (mmGetName *IProjectMock) GetNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetName.beforeGetNameCounter)
}

// MinimockGetNameDone returns true if the count of the GetName invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetNameDone() bool {
	for _, e := range m.GetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetName != nil && mm_atomic.LoadUint64(&m.afterGetNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetNameInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetNameInspect() {
	for _, e := range m.GetNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetName")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetNameCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetName != nil && mm_atomic.LoadUint64(&m.afterGetNameCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetName")
	}
}

type mIProjectMockGetProjectPath struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetProjectPathExpectation
	expectations       []*IProjectMockGetProjectPathExpectation
}

// IProjectMockGetProjectPathExpectation specifies expectation struct of the IProject.GetProjectPath
type IProjectMockGetProjectPathExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetProjectPathResults
	Counter uint64
}

// IProjectMockGetProjectPathResults contains results of the IProject.GetProjectPath
type IProjectMockGetProjectPathResults struct {
	s1 string
}

// Expect sets up expected params for IProject.GetProjectPath
func (mmGetProjectPath *mIProjectMockGetProjectPath) Expect() *mIProjectMockGetProjectPath {
	if mmGetProjectPath.mock.funcGetProjectPath != nil {
		mmGetProjectPath.mock.t.Fatalf("IProjectMock.GetProjectPath mock is already set by Set")
	}

	if mmGetProjectPath.defaultExpectation == nil {
		mmGetProjectPath.defaultExpectation = &IProjectMockGetProjectPathExpectation{}
	}

	return mmGetProjectPath
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetProjectPath
func (mmGetProjectPath *mIProjectMockGetProjectPath) Inspect(f func()) *mIProjectMockGetProjectPath {
	if mmGetProjectPath.mock.inspectFuncGetProjectPath != nil {
		mmGetProjectPath.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetProjectPath")
	}

	mmGetProjectPath.mock.inspectFuncGetProjectPath = f

	return mmGetProjectPath
}

// Return sets up results that will be returned by IProject.GetProjectPath
func (mmGetProjectPath *mIProjectMockGetProjectPath) Return(s1 string) *IProjectMock {
	if mmGetProjectPath.mock.funcGetProjectPath != nil {
		mmGetProjectPath.mock.t.Fatalf("IProjectMock.GetProjectPath mock is already set by Set")
	}

	if mmGetProjectPath.defaultExpectation == nil {
		mmGetProjectPath.defaultExpectation = &IProjectMockGetProjectPathExpectation{mock: mmGetProjectPath.mock}
	}
	mmGetProjectPath.defaultExpectation.results = &IProjectMockGetProjectPathResults{s1}
	return mmGetProjectPath.mock
}

// Set uses given function f to mock the IProject.GetProjectPath method
func (mmGetProjectPath *mIProjectMockGetProjectPath) Set(f func() (s1 string)) *IProjectMock {
	if mmGetProjectPath.defaultExpectation != nil {
		mmGetProjectPath.mock.t.Fatalf("Default expectation is already set for the IProject.GetProjectPath method")
	}

	if len(mmGetProjectPath.expectations) > 0 {
		mmGetProjectPath.mock.t.Fatalf("Some expectations are already set for the IProject.GetProjectPath method")
	}

	mmGetProjectPath.mock.funcGetProjectPath = f
	return mmGetProjectPath.mock
}

// GetProjectPath implements project.IProject
func (mmGetProjectPath *IProjectMock) GetProjectPath() (s1 string) {
	mm_atomic.AddUint64(&mmGetProjectPath.beforeGetProjectPathCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProjectPath.afterGetProjectPathCounter, 1)

	if mmGetProjectPath.inspectFuncGetProjectPath != nil {
		mmGetProjectPath.inspectFuncGetProjectPath()
	}

	if mmGetProjectPath.GetProjectPathMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProjectPath.GetProjectPathMock.defaultExpectation.Counter, 1)

		mm_results := mmGetProjectPath.GetProjectPathMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProjectPath.t.Fatal("No results are set for the IProjectMock.GetProjectPath")
		}
		return (*mm_results).s1
	}
	if mmGetProjectPath.funcGetProjectPath != nil {
		return mmGetProjectPath.funcGetProjectPath()
	}
	mmGetProjectPath.t.Fatalf("Unexpected call to IProjectMock.GetProjectPath.")
	return
}

// GetProjectPathAfterCounter returns a count of finished IProjectMock.GetProjectPath invocations
func (mmGetProjectPath *IProjectMock) GetProjectPathAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProjectPath.afterGetProjectPathCounter)
}

// GetProjectPathBeforeCounter returns a count of IProjectMock.GetProjectPath invocations
func (mmGetProjectPath *IProjectMock) GetProjectPathBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProjectPath.beforeGetProjectPathCounter)
}

// MinimockGetProjectPathDone returns true if the count of the GetProjectPath invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetProjectPathDone() bool {
	for _, e := range m.GetProjectPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProjectPathMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProjectPathCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProjectPath != nil && mm_atomic.LoadUint64(&m.afterGetProjectPathCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProjectPathInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetProjectPathInspect() {
	for _, e := range m.GetProjectPathMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetProjectPath")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProjectPathMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProjectPathCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetProjectPath")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProjectPath != nil && mm_atomic.LoadUint64(&m.afterGetProjectPathCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetProjectPath")
	}
}

type mIProjectMockGetShortName struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetShortNameExpectation
	expectations       []*IProjectMockGetShortNameExpectation
}

// IProjectMockGetShortNameExpectation specifies expectation struct of the IProject.GetShortName
type IProjectMockGetShortNameExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetShortNameResults
	Counter uint64
}

// IProjectMockGetShortNameResults contains results of the IProject.GetShortName
type IProjectMockGetShortNameResults struct {
	s1 string
}

// Expect sets up expected params for IProject.GetShortName
func (mmGetShortName *mIProjectMockGetShortName) Expect() *mIProjectMockGetShortName {
	if mmGetShortName.mock.funcGetShortName != nil {
		mmGetShortName.mock.t.Fatalf("IProjectMock.GetShortName mock is already set by Set")
	}

	if mmGetShortName.defaultExpectation == nil {
		mmGetShortName.defaultExpectation = &IProjectMockGetShortNameExpectation{}
	}

	return mmGetShortName
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetShortName
func (mmGetShortName *mIProjectMockGetShortName) Inspect(f func()) *mIProjectMockGetShortName {
	if mmGetShortName.mock.inspectFuncGetShortName != nil {
		mmGetShortName.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetShortName")
	}

	mmGetShortName.mock.inspectFuncGetShortName = f

	return mmGetShortName
}

// Return sets up results that will be returned by IProject.GetShortName
func (mmGetShortName *mIProjectMockGetShortName) Return(s1 string) *IProjectMock {
	if mmGetShortName.mock.funcGetShortName != nil {
		mmGetShortName.mock.t.Fatalf("IProjectMock.GetShortName mock is already set by Set")
	}

	if mmGetShortName.defaultExpectation == nil {
		mmGetShortName.defaultExpectation = &IProjectMockGetShortNameExpectation{mock: mmGetShortName.mock}
	}
	mmGetShortName.defaultExpectation.results = &IProjectMockGetShortNameResults{s1}
	return mmGetShortName.mock
}

// Set uses given function f to mock the IProject.GetShortName method
func (mmGetShortName *mIProjectMockGetShortName) Set(f func() (s1 string)) *IProjectMock {
	if mmGetShortName.defaultExpectation != nil {
		mmGetShortName.mock.t.Fatalf("Default expectation is already set for the IProject.GetShortName method")
	}

	if len(mmGetShortName.expectations) > 0 {
		mmGetShortName.mock.t.Fatalf("Some expectations are already set for the IProject.GetShortName method")
	}

	mmGetShortName.mock.funcGetShortName = f
	return mmGetShortName.mock
}

// GetShortName implements project.IProject
func (mmGetShortName *IProjectMock) GetShortName() (s1 string) {
	mm_atomic.AddUint64(&mmGetShortName.beforeGetShortNameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetShortName.afterGetShortNameCounter, 1)

	if mmGetShortName.inspectFuncGetShortName != nil {
		mmGetShortName.inspectFuncGetShortName()
	}

	if mmGetShortName.GetShortNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetShortName.GetShortNameMock.defaultExpectation.Counter, 1)

		mm_results := mmGetShortName.GetShortNameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetShortName.t.Fatal("No results are set for the IProjectMock.GetShortName")
		}
		return (*mm_results).s1
	}
	if mmGetShortName.funcGetShortName != nil {
		return mmGetShortName.funcGetShortName()
	}
	mmGetShortName.t.Fatalf("Unexpected call to IProjectMock.GetShortName.")
	return
}

// GetShortNameAfterCounter returns a count of finished IProjectMock.GetShortName invocations
func (mmGetShortName *IProjectMock) GetShortNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShortName.afterGetShortNameCounter)
}

// GetShortNameBeforeCounter returns a count of IProjectMock.GetShortName invocations
func (mmGetShortName *IProjectMock) GetShortNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetShortName.beforeGetShortNameCounter)
}

// MinimockGetShortNameDone returns true if the count of the GetShortName invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetShortNameDone() bool {
	for _, e := range m.GetShortNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetShortNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetShortNameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetShortName != nil && mm_atomic.LoadUint64(&m.afterGetShortNameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetShortNameInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetShortNameInspect() {
	for _, e := range m.GetShortNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetShortName")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetShortNameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetShortNameCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetShortName")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetShortName != nil && mm_atomic.LoadUint64(&m.afterGetShortNameCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetShortName")
	}
}

type mIProjectMockGetType struct {
	mock               *IProjectMock
	defaultExpectation *IProjectMockGetTypeExpectation
	expectations       []*IProjectMockGetTypeExpectation
}

// IProjectMockGetTypeExpectation specifies expectation struct of the IProject.GetType
type IProjectMockGetTypeExpectation struct {
	mock *IProjectMock

	results *IProjectMockGetTypeResults
	Counter uint64
}

// IProjectMockGetTypeResults contains results of the IProject.GetType
type IProjectMockGetTypeResults struct {
	t1 mm_project.Type
}

// Expect sets up expected params for IProject.GetType
func (mmGetType *mIProjectMockGetType) Expect() *mIProjectMockGetType {
	if mmGetType.mock.funcGetType != nil {
		mmGetType.mock.t.Fatalf("IProjectMock.GetType mock is already set by Set")
	}

	if mmGetType.defaultExpectation == nil {
		mmGetType.defaultExpectation = &IProjectMockGetTypeExpectation{}
	}

	return mmGetType
}

// Inspect accepts an inspector function that has same arguments as the IProject.GetType
func (mmGetType *mIProjectMockGetType) Inspect(f func()) *mIProjectMockGetType {
	if mmGetType.mock.inspectFuncGetType != nil {
		mmGetType.mock.t.Fatalf("Inspect function is already set for IProjectMock.GetType")
	}

	mmGetType.mock.inspectFuncGetType = f

	return mmGetType
}

// Return sets up results that will be returned by IProject.GetType
func (mmGetType *mIProjectMockGetType) Return(t1 mm_project.Type) *IProjectMock {
	if mmGetType.mock.funcGetType != nil {
		mmGetType.mock.t.Fatalf("IProjectMock.GetType mock is already set by Set")
	}

	if mmGetType.defaultExpectation == nil {
		mmGetType.defaultExpectation = &IProjectMockGetTypeExpectation{mock: mmGetType.mock}
	}
	mmGetType.defaultExpectation.results = &IProjectMockGetTypeResults{t1}
	return mmGetType.mock
}

// Set uses given function f to mock the IProject.GetType method
func (mmGetType *mIProjectMockGetType) Set(f func() (t1 mm_project.Type)) *IProjectMock {
	if mmGetType.defaultExpectation != nil {
		mmGetType.mock.t.Fatalf("Default expectation is already set for the IProject.GetType method")
	}

	if len(mmGetType.expectations) > 0 {
		mmGetType.mock.t.Fatalf("Some expectations are already set for the IProject.GetType method")
	}

	mmGetType.mock.funcGetType = f
	return mmGetType.mock
}

// GetType implements project.IProject
func (mmGetType *IProjectMock) GetType() (t1 mm_project.Type) {
	mm_atomic.AddUint64(&mmGetType.beforeGetTypeCounter, 1)
	defer mm_atomic.AddUint64(&mmGetType.afterGetTypeCounter, 1)

	if mmGetType.inspectFuncGetType != nil {
		mmGetType.inspectFuncGetType()
	}

	if mmGetType.GetTypeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetType.GetTypeMock.defaultExpectation.Counter, 1)

		mm_results := mmGetType.GetTypeMock.defaultExpectation.results
		if mm_results == nil {
			mmGetType.t.Fatal("No results are set for the IProjectMock.GetType")
		}
		return (*mm_results).t1
	}
	if mmGetType.funcGetType != nil {
		return mmGetType.funcGetType()
	}
	mmGetType.t.Fatalf("Unexpected call to IProjectMock.GetType.")
	return
}

// GetTypeAfterCounter returns a count of finished IProjectMock.GetType invocations
func (mmGetType *IProjectMock) GetTypeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetType.afterGetTypeCounter)
}

// GetTypeBeforeCounter returns a count of IProjectMock.GetType invocations
func (mmGetType *IProjectMock) GetTypeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetType.beforeGetTypeCounter)
}

// MinimockGetTypeDone returns true if the count of the GetType invocations corresponds
// the number of defined expectations
func (m *IProjectMock) MinimockGetTypeDone() bool {
	for _, e := range m.GetTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetType != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTypeInspect logs each unmet expectation
func (m *IProjectMock) MinimockGetTypeInspect() {
	for _, e := range m.GetTypeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IProjectMock.GetType")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTypeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetType")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetType != nil && mm_atomic.LoadUint64(&m.afterGetTypeCounter) < 1 {
		m.t.Error("Expected call to IProjectMock.GetType")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IProjectMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetConfigInspect()

		m.MinimockGetFolderInspect()

		m.MinimockGetNameInspect()

		m.MinimockGetProjectPathInspect()

		m.MinimockGetShortNameInspect()

		m.MinimockGetTypeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IProjectMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IProjectMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetConfigDone() &&
		m.MinimockGetFolderDone() &&
		m.MinimockGetNameDone() &&
		m.MinimockGetProjectPathDone() &&
		m.MinimockGetShortNameDone() &&
		m.MinimockGetTypeDone()
}
