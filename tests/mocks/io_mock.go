package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"

	"github.com/Red-Sock/rscli/internal/io/colors"
)

// IOMock implements io.IO
type IOMock struct {
	t minimock.Tester

	funcError          func(in string)
	inspectFuncError   func(in string)
	afterErrorCounter  uint64
	beforeErrorCounter uint64
	ErrorMock          mIOMockError

	funcGetInput          func() (s1 string, err error)
	inspectFuncGetInput   func()
	afterGetInputCounter  uint64
	beforeGetInputCounter uint64
	GetInputMock          mIOMockGetInput

	funcGetInputOneOf          func(options []string) (s1 string)
	inspectFuncGetInputOneOf   func(options []string)
	afterGetInputOneOfCounter  uint64
	beforeGetInputOneOfCounter uint64
	GetInputOneOfMock          mIOMockGetInputOneOf

	funcPrint          func(in string)
	inspectFuncPrint   func(in string)
	afterPrintCounter  uint64
	beforePrintCounter uint64
	PrintMock          mIOMockPrint

	funcPrintColored          func(color colors.Color, in string)
	inspectFuncPrintColored   func(color colors.Color, in string)
	afterPrintColoredCounter  uint64
	beforePrintColoredCounter uint64
	PrintColoredMock          mIOMockPrintColored

	funcPrintln          func(in ...string)
	inspectFuncPrintln   func(in ...string)
	afterPrintlnCounter  uint64
	beforePrintlnCounter uint64
	PrintlnMock          mIOMockPrintln

	funcPrintlnColored          func(color colors.Color, in ...string)
	inspectFuncPrintlnColored   func(color colors.Color, in ...string)
	afterPrintlnColoredCounter  uint64
	beforePrintlnColoredCounter uint64
	PrintlnColoredMock          mIOMockPrintlnColored
}

// NewIOMock returns a mock for io.IO
func NewIOMock(t minimock.Tester) *IOMock {
	m := &IOMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ErrorMock = mIOMockError{mock: m}
	m.ErrorMock.callArgs = []*IOMockErrorParams{}

	m.GetInputMock = mIOMockGetInput{mock: m}

	m.GetInputOneOfMock = mIOMockGetInputOneOf{mock: m}
	m.GetInputOneOfMock.callArgs = []*IOMockGetInputOneOfParams{}

	m.PrintMock = mIOMockPrint{mock: m}
	m.PrintMock.callArgs = []*IOMockPrintParams{}

	m.PrintColoredMock = mIOMockPrintColored{mock: m}
	m.PrintColoredMock.callArgs = []*IOMockPrintColoredParams{}

	m.PrintlnMock = mIOMockPrintln{mock: m}
	m.PrintlnMock.callArgs = []*IOMockPrintlnParams{}

	m.PrintlnColoredMock = mIOMockPrintlnColored{mock: m}
	m.PrintlnColoredMock.callArgs = []*IOMockPrintlnColoredParams{}

	return m
}

type mIOMockError struct {
	mock               *IOMock
	defaultExpectation *IOMockErrorExpectation
	expectations       []*IOMockErrorExpectation

	callArgs []*IOMockErrorParams
	mutex    sync.RWMutex
}

// IOMockErrorExpectation specifies expectation struct of the IO.Error
type IOMockErrorExpectation struct {
	mock   *IOMock
	params *IOMockErrorParams

	Counter uint64
}

// IOMockErrorParams contains parameters of the IO.Error
type IOMockErrorParams struct {
	in string
}

// Expect sets up expected params for IO.Error
func (mmError *mIOMockError) Expect(in string) *mIOMockError {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("IOMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &IOMockErrorExpectation{}
	}

	mmError.defaultExpectation.params = &IOMockErrorParams{in}
	for _, e := range mmError.expectations {
		if minimock.Equal(e.params, mmError.defaultExpectation.params) {
			mmError.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmError.defaultExpectation.params)
		}
	}

	return mmError
}

// Inspect accepts an inspector function that has same arguments as the IO.Error
func (mmError *mIOMockError) Inspect(f func(in string)) *mIOMockError {
	if mmError.mock.inspectFuncError != nil {
		mmError.mock.t.Fatalf("Inspect function is already set for IOMock.Error")
	}

	mmError.mock.inspectFuncError = f

	return mmError
}

// Return sets up results that will be returned by IO.Error
func (mmError *mIOMockError) Return() *IOMock {
	if mmError.mock.funcError != nil {
		mmError.mock.t.Fatalf("IOMock.Error mock is already set by Set")
	}

	if mmError.defaultExpectation == nil {
		mmError.defaultExpectation = &IOMockErrorExpectation{mock: mmError.mock}
	}

	return mmError.mock
}

// Set uses given function f to mock the IO.Error method
func (mmError *mIOMockError) Set(f func(in string)) *IOMock {
	if mmError.defaultExpectation != nil {
		mmError.mock.t.Fatalf("Default expectation is already set for the IO.Error method")
	}

	if len(mmError.expectations) > 0 {
		mmError.mock.t.Fatalf("Some expectations are already set for the IO.Error method")
	}

	mmError.mock.funcError = f
	return mmError.mock
}

// Error implements io.IO
func (mmError *IOMock) Error(in string) {
	mm_atomic.AddUint64(&mmError.beforeErrorCounter, 1)
	defer mm_atomic.AddUint64(&mmError.afterErrorCounter, 1)

	if mmError.inspectFuncError != nil {
		mmError.inspectFuncError(in)
	}

	mm_params := &IOMockErrorParams{in}

	// Record call args
	mmError.ErrorMock.mutex.Lock()
	mmError.ErrorMock.callArgs = append(mmError.ErrorMock.callArgs, mm_params)
	mmError.ErrorMock.mutex.Unlock()

	for _, e := range mmError.ErrorMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmError.ErrorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmError.ErrorMock.defaultExpectation.Counter, 1)
		mm_want := mmError.ErrorMock.defaultExpectation.params
		mm_got := IOMockErrorParams{in}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmError.t.Errorf("IOMock.Error got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmError.funcError != nil {
		mmError.funcError(in)
		return
	}
	mmError.t.Fatalf("Unexpected call to IOMock.Error. %v", in)

}

// ErrorAfterCounter returns a count of finished IOMock.Error invocations
func (mmError *IOMock) ErrorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.afterErrorCounter)
}

// ErrorBeforeCounter returns a count of IOMock.Error invocations
func (mmError *IOMock) ErrorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmError.beforeErrorCounter)
}

// Calls returns a list of arguments used in each call to IOMock.Error.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmError *mIOMockError) Calls() []*IOMockErrorParams {
	mmError.mutex.RLock()

	argCopy := make([]*IOMockErrorParams, len(mmError.callArgs))
	copy(argCopy, mmError.callArgs)

	mmError.mutex.RUnlock()

	return argCopy
}

// MinimockErrorDone returns true if the count of the Error invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockErrorDone() bool {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		return false
	}
	return true
}

// MinimockErrorInspect logs each unmet expectation
func (m *IOMock) MinimockErrorInspect() {
	for _, e := range m.ErrorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.Error with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		if m.ErrorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.Error")
		} else {
			m.t.Errorf("Expected call to IOMock.Error with params: %#v", *m.ErrorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcError != nil && mm_atomic.LoadUint64(&m.afterErrorCounter) < 1 {
		m.t.Error("Expected call to IOMock.Error")
	}
}

type mIOMockGetInput struct {
	mock               *IOMock
	defaultExpectation *IOMockGetInputExpectation
	expectations       []*IOMockGetInputExpectation
}

// IOMockGetInputExpectation specifies expectation struct of the IO.GetInput
type IOMockGetInputExpectation struct {
	mock *IOMock

	results *IOMockGetInputResults
	Counter uint64
}

// IOMockGetInputResults contains results of the IO.GetInput
type IOMockGetInputResults struct {
	s1  string
	err error
}

// Expect sets up expected params for IO.GetInput
func (mmGetInput *mIOMockGetInput) Expect() *mIOMockGetInput {
	if mmGetInput.mock.funcGetInput != nil {
		mmGetInput.mock.t.Fatalf("IOMock.GetInput mock is already set by Set")
	}

	if mmGetInput.defaultExpectation == nil {
		mmGetInput.defaultExpectation = &IOMockGetInputExpectation{}
	}

	return mmGetInput
}

// Inspect accepts an inspector function that has same arguments as the IO.GetInput
func (mmGetInput *mIOMockGetInput) Inspect(f func()) *mIOMockGetInput {
	if mmGetInput.mock.inspectFuncGetInput != nil {
		mmGetInput.mock.t.Fatalf("Inspect function is already set for IOMock.GetInput")
	}

	mmGetInput.mock.inspectFuncGetInput = f

	return mmGetInput
}

// Return sets up results that will be returned by IO.GetInput
func (mmGetInput *mIOMockGetInput) Return(s1 string, err error) *IOMock {
	if mmGetInput.mock.funcGetInput != nil {
		mmGetInput.mock.t.Fatalf("IOMock.GetInput mock is already set by Set")
	}

	if mmGetInput.defaultExpectation == nil {
		mmGetInput.defaultExpectation = &IOMockGetInputExpectation{mock: mmGetInput.mock}
	}
	mmGetInput.defaultExpectation.results = &IOMockGetInputResults{s1, err}
	return mmGetInput.mock
}

// Set uses given function f to mock the IO.GetInput method
func (mmGetInput *mIOMockGetInput) Set(f func() (s1 string, err error)) *IOMock {
	if mmGetInput.defaultExpectation != nil {
		mmGetInput.mock.t.Fatalf("Default expectation is already set for the IO.GetInput method")
	}

	if len(mmGetInput.expectations) > 0 {
		mmGetInput.mock.t.Fatalf("Some expectations are already set for the IO.GetInput method")
	}

	mmGetInput.mock.funcGetInput = f
	return mmGetInput.mock
}

// GetInput implements io.IO
func (mmGetInput *IOMock) GetInput() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetInput.beforeGetInputCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInput.afterGetInputCounter, 1)

	if mmGetInput.inspectFuncGetInput != nil {
		mmGetInput.inspectFuncGetInput()
	}

	if mmGetInput.GetInputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInput.GetInputMock.defaultExpectation.Counter, 1)

		mm_results := mmGetInput.GetInputMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInput.t.Fatal("No results are set for the IOMock.GetInput")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetInput.funcGetInput != nil {
		return mmGetInput.funcGetInput()
	}
	mmGetInput.t.Fatalf("Unexpected call to IOMock.GetInput.")
	return
}

// GetInputAfterCounter returns a count of finished IOMock.GetInput invocations
func (mmGetInput *IOMock) GetInputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInput.afterGetInputCounter)
}

// GetInputBeforeCounter returns a count of IOMock.GetInput invocations
func (mmGetInput *IOMock) GetInputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInput.beforeGetInputCounter)
}

// MinimockGetInputDone returns true if the count of the GetInput invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockGetInputDone() bool {
	for _, e := range m.GetInputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInputCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInput != nil && mm_atomic.LoadUint64(&m.afterGetInputCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInputInspect logs each unmet expectation
func (m *IOMock) MinimockGetInputInspect() {
	for _, e := range m.GetInputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IOMock.GetInput")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInputMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInputCounter) < 1 {
		m.t.Error("Expected call to IOMock.GetInput")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInput != nil && mm_atomic.LoadUint64(&m.afterGetInputCounter) < 1 {
		m.t.Error("Expected call to IOMock.GetInput")
	}
}

type mIOMockGetInputOneOf struct {
	mock               *IOMock
	defaultExpectation *IOMockGetInputOneOfExpectation
	expectations       []*IOMockGetInputOneOfExpectation

	callArgs []*IOMockGetInputOneOfParams
	mutex    sync.RWMutex
}

// IOMockGetInputOneOfExpectation specifies expectation struct of the IO.GetInputOneOf
type IOMockGetInputOneOfExpectation struct {
	mock    *IOMock
	params  *IOMockGetInputOneOfParams
	results *IOMockGetInputOneOfResults
	Counter uint64
}

// IOMockGetInputOneOfParams contains parameters of the IO.GetInputOneOf
type IOMockGetInputOneOfParams struct {
	options []string
}

// IOMockGetInputOneOfResults contains results of the IO.GetInputOneOf
type IOMockGetInputOneOfResults struct {
	s1 string
}

// Expect sets up expected params for IO.GetInputOneOf
func (mmGetInputOneOf *mIOMockGetInputOneOf) Expect(options []string) *mIOMockGetInputOneOf {
	if mmGetInputOneOf.mock.funcGetInputOneOf != nil {
		mmGetInputOneOf.mock.t.Fatalf("IOMock.GetInputOneOf mock is already set by Set")
	}

	if mmGetInputOneOf.defaultExpectation == nil {
		mmGetInputOneOf.defaultExpectation = &IOMockGetInputOneOfExpectation{}
	}

	mmGetInputOneOf.defaultExpectation.params = &IOMockGetInputOneOfParams{options}
	for _, e := range mmGetInputOneOf.expectations {
		if minimock.Equal(e.params, mmGetInputOneOf.defaultExpectation.params) {
			mmGetInputOneOf.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetInputOneOf.defaultExpectation.params)
		}
	}

	return mmGetInputOneOf
}

// Inspect accepts an inspector function that has same arguments as the IO.GetInputOneOf
func (mmGetInputOneOf *mIOMockGetInputOneOf) Inspect(f func(options []string)) *mIOMockGetInputOneOf {
	if mmGetInputOneOf.mock.inspectFuncGetInputOneOf != nil {
		mmGetInputOneOf.mock.t.Fatalf("Inspect function is already set for IOMock.GetInputOneOf")
	}

	mmGetInputOneOf.mock.inspectFuncGetInputOneOf = f

	return mmGetInputOneOf
}

// Return sets up results that will be returned by IO.GetInputOneOf
func (mmGetInputOneOf *mIOMockGetInputOneOf) Return(s1 string) *IOMock {
	if mmGetInputOneOf.mock.funcGetInputOneOf != nil {
		mmGetInputOneOf.mock.t.Fatalf("IOMock.GetInputOneOf mock is already set by Set")
	}

	if mmGetInputOneOf.defaultExpectation == nil {
		mmGetInputOneOf.defaultExpectation = &IOMockGetInputOneOfExpectation{mock: mmGetInputOneOf.mock}
	}
	mmGetInputOneOf.defaultExpectation.results = &IOMockGetInputOneOfResults{s1}
	return mmGetInputOneOf.mock
}

// Set uses given function f to mock the IO.GetInputOneOf method
func (mmGetInputOneOf *mIOMockGetInputOneOf) Set(f func(options []string) (s1 string)) *IOMock {
	if mmGetInputOneOf.defaultExpectation != nil {
		mmGetInputOneOf.mock.t.Fatalf("Default expectation is already set for the IO.GetInputOneOf method")
	}

	if len(mmGetInputOneOf.expectations) > 0 {
		mmGetInputOneOf.mock.t.Fatalf("Some expectations are already set for the IO.GetInputOneOf method")
	}

	mmGetInputOneOf.mock.funcGetInputOneOf = f
	return mmGetInputOneOf.mock
}

// When sets expectation for the IO.GetInputOneOf which will trigger the result defined by the following
// Then helper
func (mmGetInputOneOf *mIOMockGetInputOneOf) When(options []string) *IOMockGetInputOneOfExpectation {
	if mmGetInputOneOf.mock.funcGetInputOneOf != nil {
		mmGetInputOneOf.mock.t.Fatalf("IOMock.GetInputOneOf mock is already set by Set")
	}

	expectation := &IOMockGetInputOneOfExpectation{
		mock:   mmGetInputOneOf.mock,
		params: &IOMockGetInputOneOfParams{options},
	}
	mmGetInputOneOf.expectations = append(mmGetInputOneOf.expectations, expectation)
	return expectation
}

// Then sets up IO.GetInputOneOf return parameters for the expectation previously defined by the When method
func (e *IOMockGetInputOneOfExpectation) Then(s1 string) *IOMock {
	e.results = &IOMockGetInputOneOfResults{s1}
	return e.mock
}

// GetInputOneOf implements io.IO
func (mmGetInputOneOf *IOMock) GetInputOneOf(options []string) (s1 string) {
	mm_atomic.AddUint64(&mmGetInputOneOf.beforeGetInputOneOfCounter, 1)
	defer mm_atomic.AddUint64(&mmGetInputOneOf.afterGetInputOneOfCounter, 1)

	if mmGetInputOneOf.inspectFuncGetInputOneOf != nil {
		mmGetInputOneOf.inspectFuncGetInputOneOf(options)
	}

	mm_params := &IOMockGetInputOneOfParams{options}

	// Record call args
	mmGetInputOneOf.GetInputOneOfMock.mutex.Lock()
	mmGetInputOneOf.GetInputOneOfMock.callArgs = append(mmGetInputOneOf.GetInputOneOfMock.callArgs, mm_params)
	mmGetInputOneOf.GetInputOneOfMock.mutex.Unlock()

	for _, e := range mmGetInputOneOf.GetInputOneOfMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1
		}
	}

	if mmGetInputOneOf.GetInputOneOfMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetInputOneOf.GetInputOneOfMock.defaultExpectation.Counter, 1)
		mm_want := mmGetInputOneOf.GetInputOneOfMock.defaultExpectation.params
		mm_got := IOMockGetInputOneOfParams{options}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetInputOneOf.t.Errorf("IOMock.GetInputOneOf got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetInputOneOf.GetInputOneOfMock.defaultExpectation.results
		if mm_results == nil {
			mmGetInputOneOf.t.Fatal("No results are set for the IOMock.GetInputOneOf")
		}
		return (*mm_results).s1
	}
	if mmGetInputOneOf.funcGetInputOneOf != nil {
		return mmGetInputOneOf.funcGetInputOneOf(options)
	}
	mmGetInputOneOf.t.Fatalf("Unexpected call to IOMock.GetInputOneOf. %v", options)
	return
}

// GetInputOneOfAfterCounter returns a count of finished IOMock.GetInputOneOf invocations
func (mmGetInputOneOf *IOMock) GetInputOneOfAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInputOneOf.afterGetInputOneOfCounter)
}

// GetInputOneOfBeforeCounter returns a count of IOMock.GetInputOneOf invocations
func (mmGetInputOneOf *IOMock) GetInputOneOfBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetInputOneOf.beforeGetInputOneOfCounter)
}

// Calls returns a list of arguments used in each call to IOMock.GetInputOneOf.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetInputOneOf *mIOMockGetInputOneOf) Calls() []*IOMockGetInputOneOfParams {
	mmGetInputOneOf.mutex.RLock()

	argCopy := make([]*IOMockGetInputOneOfParams, len(mmGetInputOneOf.callArgs))
	copy(argCopy, mmGetInputOneOf.callArgs)

	mmGetInputOneOf.mutex.RUnlock()

	return argCopy
}

// MinimockGetInputOneOfDone returns true if the count of the GetInputOneOf invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockGetInputOneOfDone() bool {
	for _, e := range m.GetInputOneOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInputOneOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInputOneOfCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInputOneOf != nil && mm_atomic.LoadUint64(&m.afterGetInputOneOfCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInputOneOfInspect logs each unmet expectation
func (m *IOMock) MinimockGetInputOneOfInspect() {
	for _, e := range m.GetInputOneOfMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.GetInputOneOf with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetInputOneOfMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetInputOneOfCounter) < 1 {
		if m.GetInputOneOfMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.GetInputOneOf")
		} else {
			m.t.Errorf("Expected call to IOMock.GetInputOneOf with params: %#v", *m.GetInputOneOfMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetInputOneOf != nil && mm_atomic.LoadUint64(&m.afterGetInputOneOfCounter) < 1 {
		m.t.Error("Expected call to IOMock.GetInputOneOf")
	}
}

type mIOMockPrint struct {
	mock               *IOMock
	defaultExpectation *IOMockPrintExpectation
	expectations       []*IOMockPrintExpectation

	callArgs []*IOMockPrintParams
	mutex    sync.RWMutex
}

// IOMockPrintExpectation specifies expectation struct of the IO.Print
type IOMockPrintExpectation struct {
	mock   *IOMock
	params *IOMockPrintParams

	Counter uint64
}

// IOMockPrintParams contains parameters of the IO.Print
type IOMockPrintParams struct {
	in string
}

// Expect sets up expected params for IO.Print
func (mmPrint *mIOMockPrint) Expect(in string) *mIOMockPrint {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("IOMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &IOMockPrintExpectation{}
	}

	mmPrint.defaultExpectation.params = &IOMockPrintParams{in}
	for _, e := range mmPrint.expectations {
		if minimock.Equal(e.params, mmPrint.defaultExpectation.params) {
			mmPrint.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrint.defaultExpectation.params)
		}
	}

	return mmPrint
}

// Inspect accepts an inspector function that has same arguments as the IO.Print
func (mmPrint *mIOMockPrint) Inspect(f func(in string)) *mIOMockPrint {
	if mmPrint.mock.inspectFuncPrint != nil {
		mmPrint.mock.t.Fatalf("Inspect function is already set for IOMock.Print")
	}

	mmPrint.mock.inspectFuncPrint = f

	return mmPrint
}

// Return sets up results that will be returned by IO.Print
func (mmPrint *mIOMockPrint) Return() *IOMock {
	if mmPrint.mock.funcPrint != nil {
		mmPrint.mock.t.Fatalf("IOMock.Print mock is already set by Set")
	}

	if mmPrint.defaultExpectation == nil {
		mmPrint.defaultExpectation = &IOMockPrintExpectation{mock: mmPrint.mock}
	}

	return mmPrint.mock
}

// Set uses given function f to mock the IO.Print method
func (mmPrint *mIOMockPrint) Set(f func(in string)) *IOMock {
	if mmPrint.defaultExpectation != nil {
		mmPrint.mock.t.Fatalf("Default expectation is already set for the IO.Print method")
	}

	if len(mmPrint.expectations) > 0 {
		mmPrint.mock.t.Fatalf("Some expectations are already set for the IO.Print method")
	}

	mmPrint.mock.funcPrint = f
	return mmPrint.mock
}

// Print implements io.IO
func (mmPrint *IOMock) Print(in string) {
	mm_atomic.AddUint64(&mmPrint.beforePrintCounter, 1)
	defer mm_atomic.AddUint64(&mmPrint.afterPrintCounter, 1)

	if mmPrint.inspectFuncPrint != nil {
		mmPrint.inspectFuncPrint(in)
	}

	mm_params := &IOMockPrintParams{in}

	// Record call args
	mmPrint.PrintMock.mutex.Lock()
	mmPrint.PrintMock.callArgs = append(mmPrint.PrintMock.callArgs, mm_params)
	mmPrint.PrintMock.mutex.Unlock()

	for _, e := range mmPrint.PrintMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrint.PrintMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrint.PrintMock.defaultExpectation.Counter, 1)
		mm_want := mmPrint.PrintMock.defaultExpectation.params
		mm_got := IOMockPrintParams{in}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrint.t.Errorf("IOMock.Print got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrint.funcPrint != nil {
		mmPrint.funcPrint(in)
		return
	}
	mmPrint.t.Fatalf("Unexpected call to IOMock.Print. %v", in)

}

// PrintAfterCounter returns a count of finished IOMock.Print invocations
func (mmPrint *IOMock) PrintAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.afterPrintCounter)
}

// PrintBeforeCounter returns a count of IOMock.Print invocations
func (mmPrint *IOMock) PrintBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrint.beforePrintCounter)
}

// Calls returns a list of arguments used in each call to IOMock.Print.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrint *mIOMockPrint) Calls() []*IOMockPrintParams {
	mmPrint.mutex.RLock()

	argCopy := make([]*IOMockPrintParams, len(mmPrint.callArgs))
	copy(argCopy, mmPrint.callArgs)

	mmPrint.mutex.RUnlock()

	return argCopy
}

// MinimockPrintDone returns true if the count of the Print invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockPrintDone() bool {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintInspect logs each unmet expectation
func (m *IOMock) MinimockPrintInspect() {
	for _, e := range m.PrintMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.Print with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		if m.PrintMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.Print")
		} else {
			m.t.Errorf("Expected call to IOMock.Print with params: %#v", *m.PrintMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrint != nil && mm_atomic.LoadUint64(&m.afterPrintCounter) < 1 {
		m.t.Error("Expected call to IOMock.Print")
	}
}

type mIOMockPrintColored struct {
	mock               *IOMock
	defaultExpectation *IOMockPrintColoredExpectation
	expectations       []*IOMockPrintColoredExpectation

	callArgs []*IOMockPrintColoredParams
	mutex    sync.RWMutex
}

// IOMockPrintColoredExpectation specifies expectation struct of the IO.PrintColored
type IOMockPrintColoredExpectation struct {
	mock   *IOMock
	params *IOMockPrintColoredParams

	Counter uint64
}

// IOMockPrintColoredParams contains parameters of the IO.PrintColored
type IOMockPrintColoredParams struct {
	color colors.Color
	in    string
}

// Expect sets up expected params for IO.PrintColored
func (mmPrintColored *mIOMockPrintColored) Expect(color colors.Color, in string) *mIOMockPrintColored {
	if mmPrintColored.mock.funcPrintColored != nil {
		mmPrintColored.mock.t.Fatalf("IOMock.PrintColored mock is already set by Set")
	}

	if mmPrintColored.defaultExpectation == nil {
		mmPrintColored.defaultExpectation = &IOMockPrintColoredExpectation{}
	}

	mmPrintColored.defaultExpectation.params = &IOMockPrintColoredParams{color, in}
	for _, e := range mmPrintColored.expectations {
		if minimock.Equal(e.params, mmPrintColored.defaultExpectation.params) {
			mmPrintColored.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintColored.defaultExpectation.params)
		}
	}

	return mmPrintColored
}

// Inspect accepts an inspector function that has same arguments as the IO.PrintColored
func (mmPrintColored *mIOMockPrintColored) Inspect(f func(color colors.Color, in string)) *mIOMockPrintColored {
	if mmPrintColored.mock.inspectFuncPrintColored != nil {
		mmPrintColored.mock.t.Fatalf("Inspect function is already set for IOMock.PrintColored")
	}

	mmPrintColored.mock.inspectFuncPrintColored = f

	return mmPrintColored
}

// Return sets up results that will be returned by IO.PrintColored
func (mmPrintColored *mIOMockPrintColored) Return() *IOMock {
	if mmPrintColored.mock.funcPrintColored != nil {
		mmPrintColored.mock.t.Fatalf("IOMock.PrintColored mock is already set by Set")
	}

	if mmPrintColored.defaultExpectation == nil {
		mmPrintColored.defaultExpectation = &IOMockPrintColoredExpectation{mock: mmPrintColored.mock}
	}

	return mmPrintColored.mock
}

// Set uses given function f to mock the IO.PrintColored method
func (mmPrintColored *mIOMockPrintColored) Set(f func(color colors.Color, in string)) *IOMock {
	if mmPrintColored.defaultExpectation != nil {
		mmPrintColored.mock.t.Fatalf("Default expectation is already set for the IO.PrintColored method")
	}

	if len(mmPrintColored.expectations) > 0 {
		mmPrintColored.mock.t.Fatalf("Some expectations are already set for the IO.PrintColored method")
	}

	mmPrintColored.mock.funcPrintColored = f
	return mmPrintColored.mock
}

// PrintColored implements io.IO
func (mmPrintColored *IOMock) PrintColored(color colors.Color, in string) {
	mm_atomic.AddUint64(&mmPrintColored.beforePrintColoredCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintColored.afterPrintColoredCounter, 1)

	if mmPrintColored.inspectFuncPrintColored != nil {
		mmPrintColored.inspectFuncPrintColored(color, in)
	}

	mm_params := &IOMockPrintColoredParams{color, in}

	// Record call args
	mmPrintColored.PrintColoredMock.mutex.Lock()
	mmPrintColored.PrintColoredMock.callArgs = append(mmPrintColored.PrintColoredMock.callArgs, mm_params)
	mmPrintColored.PrintColoredMock.mutex.Unlock()

	for _, e := range mmPrintColored.PrintColoredMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintColored.PrintColoredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintColored.PrintColoredMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintColored.PrintColoredMock.defaultExpectation.params
		mm_got := IOMockPrintColoredParams{color, in}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintColored.t.Errorf("IOMock.PrintColored got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintColored.funcPrintColored != nil {
		mmPrintColored.funcPrintColored(color, in)
		return
	}
	mmPrintColored.t.Fatalf("Unexpected call to IOMock.PrintColored. %v %v", color, in)

}

// PrintColoredAfterCounter returns a count of finished IOMock.PrintColored invocations
func (mmPrintColored *IOMock) PrintColoredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintColored.afterPrintColoredCounter)
}

// PrintColoredBeforeCounter returns a count of IOMock.PrintColored invocations
func (mmPrintColored *IOMock) PrintColoredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintColored.beforePrintColoredCounter)
}

// Calls returns a list of arguments used in each call to IOMock.PrintColored.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintColored *mIOMockPrintColored) Calls() []*IOMockPrintColoredParams {
	mmPrintColored.mutex.RLock()

	argCopy := make([]*IOMockPrintColoredParams, len(mmPrintColored.callArgs))
	copy(argCopy, mmPrintColored.callArgs)

	mmPrintColored.mutex.RUnlock()

	return argCopy
}

// MinimockPrintColoredDone returns true if the count of the PrintColored invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockPrintColoredDone() bool {
	for _, e := range m.PrintColoredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintColoredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintColoredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintColored != nil && mm_atomic.LoadUint64(&m.afterPrintColoredCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintColoredInspect logs each unmet expectation
func (m *IOMock) MinimockPrintColoredInspect() {
	for _, e := range m.PrintColoredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.PrintColored with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintColoredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintColoredCounter) < 1 {
		if m.PrintColoredMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.PrintColored")
		} else {
			m.t.Errorf("Expected call to IOMock.PrintColored with params: %#v", *m.PrintColoredMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintColored != nil && mm_atomic.LoadUint64(&m.afterPrintColoredCounter) < 1 {
		m.t.Error("Expected call to IOMock.PrintColored")
	}
}

type mIOMockPrintln struct {
	mock               *IOMock
	defaultExpectation *IOMockPrintlnExpectation
	expectations       []*IOMockPrintlnExpectation

	callArgs []*IOMockPrintlnParams
	mutex    sync.RWMutex
}

// IOMockPrintlnExpectation specifies expectation struct of the IO.Println
type IOMockPrintlnExpectation struct {
	mock   *IOMock
	params *IOMockPrintlnParams

	Counter uint64
}

// IOMockPrintlnParams contains parameters of the IO.Println
type IOMockPrintlnParams struct {
	in []string
}

// Expect sets up expected params for IO.Println
func (mmPrintln *mIOMockPrintln) Expect(in ...string) *mIOMockPrintln {
	if mmPrintln.mock.funcPrintln != nil {
		mmPrintln.mock.t.Fatalf("IOMock.Println mock is already set by Set")
	}

	if mmPrintln.defaultExpectation == nil {
		mmPrintln.defaultExpectation = &IOMockPrintlnExpectation{}
	}

	mmPrintln.defaultExpectation.params = &IOMockPrintlnParams{in}
	for _, e := range mmPrintln.expectations {
		if minimock.Equal(e.params, mmPrintln.defaultExpectation.params) {
			mmPrintln.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintln.defaultExpectation.params)
		}
	}

	return mmPrintln
}

// Inspect accepts an inspector function that has same arguments as the IO.Println
func (mmPrintln *mIOMockPrintln) Inspect(f func(in ...string)) *mIOMockPrintln {
	if mmPrintln.mock.inspectFuncPrintln != nil {
		mmPrintln.mock.t.Fatalf("Inspect function is already set for IOMock.Println")
	}

	mmPrintln.mock.inspectFuncPrintln = f

	return mmPrintln
}

// Return sets up results that will be returned by IO.Println
func (mmPrintln *mIOMockPrintln) Return() *IOMock {
	if mmPrintln.mock.funcPrintln != nil {
		mmPrintln.mock.t.Fatalf("IOMock.Println mock is already set by Set")
	}

	if mmPrintln.defaultExpectation == nil {
		mmPrintln.defaultExpectation = &IOMockPrintlnExpectation{mock: mmPrintln.mock}
	}

	return mmPrintln.mock
}

// Set uses given function f to mock the IO.Println method
func (mmPrintln *mIOMockPrintln) Set(f func(in ...string)) *IOMock {
	if mmPrintln.defaultExpectation != nil {
		mmPrintln.mock.t.Fatalf("Default expectation is already set for the IO.Println method")
	}

	if len(mmPrintln.expectations) > 0 {
		mmPrintln.mock.t.Fatalf("Some expectations are already set for the IO.Println method")
	}

	mmPrintln.mock.funcPrintln = f
	return mmPrintln.mock
}

// Println implements io.IO
func (mmPrintln *IOMock) Println(in ...string) {
	mm_atomic.AddUint64(&mmPrintln.beforePrintlnCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintln.afterPrintlnCounter, 1)

	if mmPrintln.inspectFuncPrintln != nil {
		mmPrintln.inspectFuncPrintln(in...)
	}

	mm_params := &IOMockPrintlnParams{in}

	// Record call args
	mmPrintln.PrintlnMock.mutex.Lock()
	mmPrintln.PrintlnMock.callArgs = append(mmPrintln.PrintlnMock.callArgs, mm_params)
	mmPrintln.PrintlnMock.mutex.Unlock()

	for _, e := range mmPrintln.PrintlnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintln.PrintlnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintln.PrintlnMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintln.PrintlnMock.defaultExpectation.params
		mm_got := IOMockPrintlnParams{in}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintln.t.Errorf("IOMock.Println got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintln.funcPrintln != nil {
		mmPrintln.funcPrintln(in...)
		return
	}
	mmPrintln.t.Fatalf("Unexpected call to IOMock.Println. %v", in)

}

// PrintlnAfterCounter returns a count of finished IOMock.Println invocations
func (mmPrintln *IOMock) PrintlnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintln.afterPrintlnCounter)
}

// PrintlnBeforeCounter returns a count of IOMock.Println invocations
func (mmPrintln *IOMock) PrintlnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintln.beforePrintlnCounter)
}

// Calls returns a list of arguments used in each call to IOMock.Println.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintln *mIOMockPrintln) Calls() []*IOMockPrintlnParams {
	mmPrintln.mutex.RLock()

	argCopy := make([]*IOMockPrintlnParams, len(mmPrintln.callArgs))
	copy(argCopy, mmPrintln.callArgs)

	mmPrintln.mutex.RUnlock()

	return argCopy
}

// MinimockPrintlnDone returns true if the count of the Println invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockPrintlnDone() bool {
	for _, e := range m.PrintlnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintlnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintlnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintln != nil && mm_atomic.LoadUint64(&m.afterPrintlnCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintlnInspect logs each unmet expectation
func (m *IOMock) MinimockPrintlnInspect() {
	for _, e := range m.PrintlnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.Println with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintlnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintlnCounter) < 1 {
		if m.PrintlnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.Println")
		} else {
			m.t.Errorf("Expected call to IOMock.Println with params: %#v", *m.PrintlnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintln != nil && mm_atomic.LoadUint64(&m.afterPrintlnCounter) < 1 {
		m.t.Error("Expected call to IOMock.Println")
	}
}

type mIOMockPrintlnColored struct {
	mock               *IOMock
	defaultExpectation *IOMockPrintlnColoredExpectation
	expectations       []*IOMockPrintlnColoredExpectation

	callArgs []*IOMockPrintlnColoredParams
	mutex    sync.RWMutex
}

// IOMockPrintlnColoredExpectation specifies expectation struct of the IO.PrintlnColored
type IOMockPrintlnColoredExpectation struct {
	mock   *IOMock
	params *IOMockPrintlnColoredParams

	Counter uint64
}

// IOMockPrintlnColoredParams contains parameters of the IO.PrintlnColored
type IOMockPrintlnColoredParams struct {
	color colors.Color
	in    []string
}

// Expect sets up expected params for IO.PrintlnColored
func (mmPrintlnColored *mIOMockPrintlnColored) Expect(color colors.Color, in ...string) *mIOMockPrintlnColored {
	if mmPrintlnColored.mock.funcPrintlnColored != nil {
		mmPrintlnColored.mock.t.Fatalf("IOMock.PrintlnColored mock is already set by Set")
	}

	if mmPrintlnColored.defaultExpectation == nil {
		mmPrintlnColored.defaultExpectation = &IOMockPrintlnColoredExpectation{}
	}

	mmPrintlnColored.defaultExpectation.params = &IOMockPrintlnColoredParams{color, in}
	for _, e := range mmPrintlnColored.expectations {
		if minimock.Equal(e.params, mmPrintlnColored.defaultExpectation.params) {
			mmPrintlnColored.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrintlnColored.defaultExpectation.params)
		}
	}

	return mmPrintlnColored
}

// Inspect accepts an inspector function that has same arguments as the IO.PrintlnColored
func (mmPrintlnColored *mIOMockPrintlnColored) Inspect(f func(color colors.Color, in ...string)) *mIOMockPrintlnColored {
	if mmPrintlnColored.mock.inspectFuncPrintlnColored != nil {
		mmPrintlnColored.mock.t.Fatalf("Inspect function is already set for IOMock.PrintlnColored")
	}

	mmPrintlnColored.mock.inspectFuncPrintlnColored = f

	return mmPrintlnColored
}

// Return sets up results that will be returned by IO.PrintlnColored
func (mmPrintlnColored *mIOMockPrintlnColored) Return() *IOMock {
	if mmPrintlnColored.mock.funcPrintlnColored != nil {
		mmPrintlnColored.mock.t.Fatalf("IOMock.PrintlnColored mock is already set by Set")
	}

	if mmPrintlnColored.defaultExpectation == nil {
		mmPrintlnColored.defaultExpectation = &IOMockPrintlnColoredExpectation{mock: mmPrintlnColored.mock}
	}

	return mmPrintlnColored.mock
}

// Set uses given function f to mock the IO.PrintlnColored method
func (mmPrintlnColored *mIOMockPrintlnColored) Set(f func(color colors.Color, in ...string)) *IOMock {
	if mmPrintlnColored.defaultExpectation != nil {
		mmPrintlnColored.mock.t.Fatalf("Default expectation is already set for the IO.PrintlnColored method")
	}

	if len(mmPrintlnColored.expectations) > 0 {
		mmPrintlnColored.mock.t.Fatalf("Some expectations are already set for the IO.PrintlnColored method")
	}

	mmPrintlnColored.mock.funcPrintlnColored = f
	return mmPrintlnColored.mock
}

// PrintlnColored implements io.IO
func (mmPrintlnColored *IOMock) PrintlnColored(color colors.Color, in ...string) {
	mm_atomic.AddUint64(&mmPrintlnColored.beforePrintlnColoredCounter, 1)
	defer mm_atomic.AddUint64(&mmPrintlnColored.afterPrintlnColoredCounter, 1)

	if mmPrintlnColored.inspectFuncPrintlnColored != nil {
		mmPrintlnColored.inspectFuncPrintlnColored(color, in...)
	}

	mm_params := &IOMockPrintlnColoredParams{color, in}

	// Record call args
	mmPrintlnColored.PrintlnColoredMock.mutex.Lock()
	mmPrintlnColored.PrintlnColoredMock.callArgs = append(mmPrintlnColored.PrintlnColoredMock.callArgs, mm_params)
	mmPrintlnColored.PrintlnColoredMock.mutex.Unlock()

	for _, e := range mmPrintlnColored.PrintlnColoredMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPrintlnColored.PrintlnColoredMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrintlnColored.PrintlnColoredMock.defaultExpectation.Counter, 1)
		mm_want := mmPrintlnColored.PrintlnColoredMock.defaultExpectation.params
		mm_got := IOMockPrintlnColoredParams{color, in}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrintlnColored.t.Errorf("IOMock.PrintlnColored got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPrintlnColored.funcPrintlnColored != nil {
		mmPrintlnColored.funcPrintlnColored(color, in...)
		return
	}
	mmPrintlnColored.t.Fatalf("Unexpected call to IOMock.PrintlnColored. %v %v", color, in)

}

// PrintlnColoredAfterCounter returns a count of finished IOMock.PrintlnColored invocations
func (mmPrintlnColored *IOMock) PrintlnColoredAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintlnColored.afterPrintlnColoredCounter)
}

// PrintlnColoredBeforeCounter returns a count of IOMock.PrintlnColored invocations
func (mmPrintlnColored *IOMock) PrintlnColoredBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrintlnColored.beforePrintlnColoredCounter)
}

// Calls returns a list of arguments used in each call to IOMock.PrintlnColored.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrintlnColored *mIOMockPrintlnColored) Calls() []*IOMockPrintlnColoredParams {
	mmPrintlnColored.mutex.RLock()

	argCopy := make([]*IOMockPrintlnColoredParams, len(mmPrintlnColored.callArgs))
	copy(argCopy, mmPrintlnColored.callArgs)

	mmPrintlnColored.mutex.RUnlock()

	return argCopy
}

// MinimockPrintlnColoredDone returns true if the count of the PrintlnColored invocations corresponds
// the number of defined expectations
func (m *IOMock) MinimockPrintlnColoredDone() bool {
	for _, e := range m.PrintlnColoredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintlnColoredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintlnColoredCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintlnColored != nil && mm_atomic.LoadUint64(&m.afterPrintlnColoredCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrintlnColoredInspect logs each unmet expectation
func (m *IOMock) MinimockPrintlnColoredInspect() {
	for _, e := range m.PrintlnColoredMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to IOMock.PrintlnColored with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrintlnColoredMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrintlnColoredCounter) < 1 {
		if m.PrintlnColoredMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to IOMock.PrintlnColored")
		} else {
			m.t.Errorf("Expected call to IOMock.PrintlnColored with params: %#v", *m.PrintlnColoredMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrintlnColored != nil && mm_atomic.LoadUint64(&m.afterPrintlnColoredCounter) < 1 {
		m.t.Error("Expected call to IOMock.PrintlnColored")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IOMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockErrorInspect()

		m.MinimockGetInputInspect()

		m.MinimockGetInputOneOfInspect()

		m.MinimockPrintInspect()

		m.MinimockPrintColoredInspect()

		m.MinimockPrintlnInspect()

		m.MinimockPrintlnColoredInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IOMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IOMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockErrorDone() &&
		m.MinimockGetInputDone() &&
		m.MinimockGetInputOneOfDone() &&
		m.MinimockPrintDone() &&
		m.MinimockPrintColoredDone() &&
		m.MinimockPrintlnDone() &&
		m.MinimockPrintlnColoredDone()
}
