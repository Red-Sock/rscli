## Старт приложения
Go достаточно простой язык с точки зрения построения приложений. В отличии от C# или Java в Go не так распространены фреймворки или огромные библиотеки.

Так же, можно сказать что Go это преимущественно язык разработки микросервисов, а значит критически важно уметь писать и структурировать программы лаконично и как можно более простым и понятным способом.

## main.go
Приложение на Go начинается с функции main в файле main.go.

В Go нет чётких правил расположения этого файла в структуре проекта. Как правило такие правила формируются на уровне команды или компании.

Наиболее частые варианты расположения файла - в корне проекта или в специальной дерриктории cmd

> project/cmd/main.go

Так же допускаются варианты, когда несколько приложений могут использовать один и тот же функционал (например админка, которая должна запускаться как отдельное приложение или крон задача), тогда в деррикторию cmd добавляется дополнительный слой
> project/cmd/project/main.go
> project/cmd/cron/main.go
> project/cmd/admin/main.go

## Go.mod
Ещё одним важным моментом в полноценном проекте на Go является модуль. Создать его можно с помощью утилиты mod предоставляемой стандартными средствами. Так например команда

```shell
go mod init github.com/project-folder/project-name
```

Создаст файл go.mod для проекта с названием github.com/project-folder/project-name.

Модули были представлены в версии 1.11 и по сей день остаются самым удобным (и идущем из коробки) вариантом версионирования и разбиения проектов на пакеты.

Как и с расположением main файла, отсутствуют чёткие правила его оформления. Некоторые команды в угоду скорости запуска проекта могут просто наполнять функцию main всеми необходимыми зависимостями, подключением к базам, к другим api и многое другое.

Однако гораздо удобнее будет разбить процесс инициализации на функции или вовсе вынести его в отдельный пакет bootstrap

Например в виде:
> project/cmd/bootstrap/
> /db.go
> /cache.go
> /api.go

## Internal
Ещё одна интересная особенность, которая была представлена в go 1.11 - папка internal

Назначение internal - внутренние файлы проекта, необходимые для использования только внутри проекта. Так было и до 1.11, однако в последствии на уровне языка было закреплена возможность клиента библиотеки использовать содержимоей internal (иными словами пользователь импортирующий чужой проект не может пользоваться файлаи проекта из папки internal - на уровне компилятора будет выпадать ошибка)

### Интерфейсы:
Бизнес логики
> internal/service/interfaces.go

Слоя с данными
> internal/data/interfaces.go

Внешних зависимостей
> internal/external_api/interfaces.go

### Реализации
могут лежать рядом с описанием интерфейсов
Бизнес логики
> internal/service/v1/service.go

Слоя с данными
> internal/data/pg/conn.go

Внешних зависимостей
> internal/external_api/v1/client.go

### Вспомогательные утилиты
могут так же лежать в internals. Однако стоит помнить, что папка utils не должна превращаться в god object способный делать всё со всем.

Если общих функций много, лучше распределять их по тематикам

> internal/utils/slices/....
> internal/utils/strings/....
> internal/utils/numbers/....

## Конфигурирование

Для конфигурирования приложений на Go существует как большое количество различных библиотек так и специально разработанных решений внутри разных компаний.

Для управления конфигурацией лучше всего попробовать стандартные решения (например Viper), понять что устраивает, что нет и дальше смотреть в сторону других библиотек.

### config.yaml | .json | toml

Наиболее популярными языками для конфигурирования являются yaml, json и реже toml.

Хранить конфигурацию можно как в корне проекта, так и в специальной папке config, на случай если конфигурация отличается от окружения к окружению
> project/config/dev.yaml
> project/config/prod.yaml
> project/config/stg.yaml

### internal/config/config.go

Так как конфигурация приложения - это его внутренняя потребность, наиболее понятным будет расположить Go файлы с конфигурацией в специальном пакете internal

### pkg
Папка pkg работает как подсказка для клиента некоего сервиса. В ней должны лежать все зависимости необходимые для взаимодействия с сервисом.

Например, там могут лежать скомпилированные grpc клиенты

> pkg/project/client.pb.go
> pkg/project/client.pb.js
> ...

Или swagger документация

> pkg/swagger/...


В остальном, разбиение на пакеты является исключетельно общесогласуемым и чёткой договорённости на уровне языка по поводу устройства проектов нет.

# Архитектуры

## Сквозная инъекция
Тем не менее существует несколько общепринятных шаблонов, по которым можно пытаться строить свои программы.

Одним из наиболее употрибимых паттернов является сквозная инъекция зависимостей.

По этому паттерну в рамках main.go производится инициализация всех зависимостей (внешние API/ подключения базы данных)

На их основе формируется второй уровень - абстрактный доступ к данным (например, метод Репозиторий)

В последствии инициализируется сервис бизнес-логики, в который подкладываются репозитории из предыдущего шага.

Напоследок инициализируется сервис внешнего API, в который закладывается бизнес логика из предыдущего шага.

Такой подход обеспечивает простоту понимания устройства проекта и зависимостей в нём.

## Полноценная инъекция зависимостей
Тут можно рассказать про то как она устроена в uber (у них под это есть свой фреймворк)

Этот способ не слишком очевидный и может показаться сложным как для настройки, так и для понимания
