package init_new

import (
	"fmt"
	"os"
	"path"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/Red-Sock/rscli/internal/config"
	"github.com/Red-Sock/rscli/internal/io/colors"
	"github.com/Red-Sock/rscli/internal/io/folder"
	"github.com/Red-Sock/rscli/internal/processor"
	"github.com/Red-Sock/rscli/plugins/project/actions/go_actions/renamer"
	"github.com/Red-Sock/rscli/plugins/project/go_project/patterns"
	"github.com/Red-Sock/rscli/tests"
	"github.com/Red-Sock/rscli/tests/mocks"
)

func Test_InitProject(t *testing.T) {
	dirPath := path.Join(os.TempDir(), t.Name())

	require.NoError(t, os.RemoveAll(dirPath))
	require.NoError(t, os.MkdirAll(dirPath, 0777))
	defer func() {
		require.NoError(t, os.RemoveAll(dirPath))
	}()

	projFullName := defaultGitPath + "/" + projName

	io := mocks.NewIOMock(t)
	coloredPrintlnOutputs := []struct {
		color colors.Color
		text  string
	}{
		{
			color: colors.ColorCyan,
			text:  fmt.Sprintf(ackProjectNameMessagePattern, projFullName),
		},
		{
			color: colors.ColorGreen,
			text:  fmt.Sprintf(newProjectInitMessage, projFullName, dirPath+"/"+projName),
		},
	}
	coloredPrintlnIdx := 0

	io.PrintlnColoredMock.Set(func(color colors.Color, in ...string) {
		for _, text := range in {
			require.Equal(t, coloredPrintlnOutputs[coloredPrintlnIdx].color, color)
			require.Equal(t, coloredPrintlnOutputs[coloredPrintlnIdx].text, text)
			coloredPrintlnIdx++
		}
	})

	printlnOutputs := []string{
		"Starting project constructor",
		"Project actions performed",
	}
	printlnIndex := 0
	io.PrintlnMock.Set(func(in ...string) {
		for _, text := range in {
			require.Equal(t, printlnOutputs[printlnIndex], text)
			printlnIndex++
		}
	})

	args := []string{projName}

	cfg := &config.RsCliConfig{
		DefaultProjectGitPath: defaultGitPath,
	}

	basicProc := processor.New(
		processor.WithIo(io),
		processor.WithWd(dirPath),
		processor.WithConfig(cfg),
	)

	cmd := NewCommand(basicProc)

	cmd.SetArgs(args)
	err := cmd.Execute()
	require.NoError(t, err)

	projectPath := path.Join(dirPath, projName)

	assertFile(t, projectPath, patterns.Dockerfile)
	assertFile(t, projectPath, patterns.Makefile)

	readme := patterns.Readme.Copy()
	renamer.ReplaceProjectName(projFullName, readme)
	assertFile(t, projectPath, readme)

	rscliMk := patterns.RscliMK.Copy()
	renamer.ReplaceProjectName(projName, rscliMk)
	assertFile(t, projectPath, rscliMk)

	stat, err := os.Stat(path.Join(projectPath, patterns.GoMod))
	require.NoError(t, err)
	require.False(t, stat.IsDir())
	{
		basicConfig := []byte(`
app_info:
    name: github.com/RedSock/test_proj
    version: v0.0.1
    startup_duration: 10s
`)[1:]

		assertFile(t, projectPath,
			&folder.Folder{
				Name: patterns.ConfigsFolder,
				Inner: []*folder.Folder{
					{
						Name:    patterns.ConfigDevYamlFile,
						Content: basicConfig,
					},
					{
						Name:    patterns.ConfigMasterYamlFile,
						Content: basicConfig,
					},
					{
						Name:    patterns.ConfigTemplateYaml,
						Content: basicConfig,
					},
				},
			})
	}

	{
		loadConfigFile := []byte(`
// Code generated by RedSock CLI. DO NOT EDIT.

package config

import (
	"flag"

	errors "github.com/Red-Sock/trace-errors"
	"github.com/godverv/matreshka"
)

var ErrAlreadyLoaded = errors.New("config already loaded")

type Config struct {
	AppInfo matreshka.AppInfo
}

var defaultConfig Config

const (
	devConfigPath  = "./config/dev.yaml"
	prodConfigPath = "./config/config.yaml"
)

func Load() (Config, error) {
	if defaultConfig.AppInfo.Name != "" {
		return defaultConfig, ErrAlreadyLoaded
	}

	var cfgPath string
	var isDevBuild bool

	flag.StringVar(&cfgPath, "config", "", "Path to configuration file")
	flag.BoolVar(&isDevBuild, "dev", false, "Flag turns on a dev config at ./config/dev.yaml")
	flag.Parse()

	if cfgPath == "" {
		if isDevBuild {
			cfgPath = devConfigPath
		} else {
			cfgPath = prodConfigPath
		}
	}

	rootConfig, err := matreshka.ReadConfigs(cfgPath)
	if err != nil {
		return defaultConfig, errors.Wrap(err, "error reading matreshka config")
	}

	defaultConfig.AppInfo = rootConfig.AppInfo

	return defaultConfig, nil
}
`)[1:]

		assertFile(t, projectPath, &folder.Folder{
			Name: patterns.InternalFolder,
			Inner: []*folder.Folder{
				{
					Name: patterns.ConfigsFolder,
					Inner: []*folder.Folder{
						{
							Name:    patterns.ConfigLoadFileName,
							Content: loadConfigFile,
						},
					},
				},
			},
		})
	}

	mainGoFile := patterns.MainFile.Copy()
	renamer.ReplaceProjectName(projFullName, mainGoFile)
	assertFile(t, path.Join(projectPath, patterns.CmdFolder, patterns.ServiceFolder), mainGoFile)

}

func assertFile(t *testing.T, dirPath string, expected *folder.Folder) {
	if len(expected.Content) != 0 {
		file, err := os.ReadFile(path.Join(dirPath, expected.Name))
		require.NoError(t, err)
		if len(expected.Content) < 800 {
			assert.Equal(t, string(expected.Content), string(file))
		} else {
			tests.CompareLongStrings(t, expected.Content, file)
		}
		return
	}

	for _, innerF := range expected.Inner {
		assertFile(t, path.Join(dirPath, expected.Name), innerF)
	}
}
