package go_actions

import (
	"path"
	"testing"
	"time"

	"github.com/godverv/matreshka/environment"
	"github.com/stretchr/testify/require"

	projPatterns "github.com/Red-Sock/rscli/plugins/project/go_project/patterns"
	"github.com/Red-Sock/rscli/tests/test_prepare"
)

func Test_PrepareConfig(t *testing.T) {
	t.Parallel()

	type test struct {
		envVariables  []*environment.Variable
		expectedFiles map[string][]byte
	}

	fullEnvConfig := []byte(`
app_info:
    name: test_project
    version: v0.0.1
    startup_duration: 10s
environment:
    - name: test_string_variable
      type: string
      value: test_value
    - name: test_int_variable
      type: int
      value: 1
    - name: test_bool_variable
      type: bool
      value: true
    - name: test_float_variable
      type: float
      value: 1.1
    - name: test_duration_variable
      type: duration
      value: 5s
    - name: test_string_variables
      type: string
      value:
        - test_value
        - test_value2
    - name: test_int_variables
      type: int
      value:
        - 1
        - 2
    - name: test_bool_variables
      type: bool
      value:
        - true
        - false
    - name: test_float_variables
      type: float
      value:
        - 1.1
        - 2.2
    - name: test_duration_variables
      type: duration
      value:
        - 5s
        - 8s
`)[1:]

	tests := map[string]test{
		"environment_variables": {
			envVariables: []*environment.Variable{
				// Single values
				{
					Name:  "test_string_variable",
					Type:  environment.VariableTypeStr,
					Value: "test_value",
				},
				{
					Name:  "test_int_variable",
					Type:  environment.VariableTypeInt,
					Value: 1,
				},
				{
					Name:  "test_bool_variable",
					Type:  environment.VariableTypeBool,
					Value: true,
				},
				{
					Name:  "test_float_variable",
					Type:  environment.VariableTypeFloat,
					Value: 1.1,
				},
				{
					Name:  "test_duration_variable",
					Type:  environment.VariableTypeDuration,
					Value: time.Second * 5,
				},
				// Multiple values
				{
					Name:  "test_string_variables",
					Type:  environment.VariableTypeStr,
					Value: []string{"test_value", "test_value2"},
				},
				{
					Name:  "test_int_variables",
					Type:  environment.VariableTypeInt,
					Value: []int{1, 2},
				},
				{
					Name:  "test_bool_variables",
					Type:  environment.VariableTypeBool,
					Value: []bool{true, false},
				},
				{
					Name:  "test_float_variables",
					Type:  environment.VariableTypeFloat,
					Value: []float64{1.1, 2.2},
				},
				{
					Name:  "test_duration_variables",
					Type:  environment.VariableTypeDuration,
					Value: []time.Duration{time.Second * 5, time.Second * 8},
				},
			},
			expectedFiles: map[string][]byte{
				path.Join(projPatterns.ConfigsFolder, projPatterns.ConfigMasterYamlFile): fullEnvConfig,
				path.Join(projPatterns.ConfigsFolder, projPatterns.ConfigTemplateYaml):   fullEnvConfig,
				path.Join(projPatterns.ConfigsFolder, projPatterns.ConfigDevYamlFile):    fullEnvConfig,

				path.Join(projPatterns.InternalFolder, projPatterns.ConfigsFolder,
					projPatterns.ConfigEnvironmentFileName): []byte(`
// Code generated by RedSock CLI. DO NOT EDIT.

package config

import ( 
     "time"
)

type EnvironmentConfig struct { 
    TestStringVariable string
    TestIntVariable int
    TestBoolVariable bool
    TestFloatVariable float64
    TestDurationVariable time.Duration
    TestStringVariables []string
    TestIntVariables []int
    TestBoolVariables []bool
    TestFloatVariables []float64
    TestDurationVariables []time.Duration
}
`)[1:],
			},
		},
	}

	for name, tc := range tests {
		name, tc := name, tc
		t.Run(name, func(t *testing.T) {
			t.Parallel()
			projectMock := test_prepare.PrepareProject(t)
			defer projectMock.Clean(t)

			cfg := projectMock.Cfg

			cfg.Environment = append(cfg.Environment, tc.envVariables...)

			require.NoError(t, PrepareGoConfigFolderAction{}.Do(projectMock.Project))

			for pathToFile, expected := range tc.expectedFiles {
				actualFile := projectMock.GetFolder().GetByPath(pathToFile)
				require.Equal(t, string(actualFile.Content), string(expected))
			}
		})
	}
}
