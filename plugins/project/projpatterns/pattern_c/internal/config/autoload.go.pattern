// Code generated by RedSock CLI. DO NOT EDIT.

package config

import (
	"flag"

	errors "github.com/Red-Sock/trace-errors"
	"github.com/godverv/matreshka"
	"github.com/godverv/matreshka/resources"
	"github.com/godverv/matreshka/servers"
)

var ErrAlreadyLoaded = errors.New("config already loaded")

var defaultConfig config

const (
	devConfigPath  = "./config/dev.yaml"
	prodConfigPath = "./config/config.yaml"
)

func Load() (Config, error) {
	if defaultConfig.AppInfo.Name != "" {
		return &defaultConfig, ErrAlreadyLoaded
	}

	var cfgPath string
	var isDevBuild bool

	flag.StringVar(&cfgPath, "config", "", "Path to configuration file")
	flag.BoolVar(&isDevBuild, "dev", false, "Flag turns on a dev config at ./config/dev.yaml")
	flag.Parse()

	if cfgPath == "" {
		if isDevBuild {
			cfgPath = devConfigPath
		} else {
			cfgPath = prodConfigPath
		}
	}
	var err error
	defaultConfig.AppConfig, err = matreshka.ReadConfigs(cfgPath)
	if err != nil {
		return nil, errors.Wrap(err, "error reading matreshka config")
	}

	return &defaultConfig, nil
}

type config struct {
	matreshka.AppConfig
	envConfig EnvironmentConfig
}

func (c *config) GetAppInfo() matreshka.AppInfo {
	return c.AppInfo
}

func (c *config) GetServers() API {
	return &c.AppConfig.Servers
}

func (c *config) GetDataSources() Resources {
	return &c.AppConfig.DataSources
}

func (c *config) GetEnvironment() EnvironmentConfig {
	return c.envConfig
}

type Config interface {
	GetAppInfo() matreshka.AppInfo

	GetServers() API
	GetDataSources() Resources

	GetEnvironment() EnvironmentConfig
}

type API interface {
	REST(name string) (*servers.Rest, error)
	GRPC(name string) (*servers.GRPC, error)
}

type Resources interface {
	Postgres(name string) (*resources.Postgres, error)
	Telegram(name string) (*resources.Telegram, error)
	Redis(name string) (*resources.Redis, error)
	GRPC(name string) (*resources.GRPC, error)
	Sqlite(name string) (*resources.Sqlite, error)
}
