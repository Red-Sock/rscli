// Code generated by RedSock CLI. DO NOT EDIT.

package postgres

import (
	"context"

	"github.com/Red-Sock/trace-errors"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

// EXPEREMENTAL
// TxManager - transaction mechanism that allows to call multiple
// data layer functions from service layer
// Shouldn't be used in a long living methods:
//
//	e.g.
//		open transaction ->
//		  do sql select from table 1 ->
//									go to another service via http ->
//									recieve http response          <-
//			   do insert to table_2 <-
//			 do update to table_3 <-
//		   do delete to table_4 <-
//		close transaction <-
//
// instead it whould be better to:
//
//	do sql select
//	go to another service via http ->
//	recieve http response          <-
//
//	open transaction ->
//		do insert to table_2 ->
//		do update to table_3 ->
//		do delete to table_4 ->
//	close transaction <-
type TxManager interface {
	Conn
	ExtractTx(ctx context.Context) Conn
	BeginTx(ctx context.Context) (context.Context, error)
}

type Conn interface {
	Begin(ctx context.Context) (pgx.Tx, error)
	Commit(ctx context.Context) error
	Rollback(ctx context.Context) error

	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)

	Prepare(ctx context.Context, name string, sql string) (*pgconn.StatementDescription, error)

	Exec(ctx context.Context, sql string, arguments ...any) (commandTag pgconn.CommandTag, err error)
	Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)
	QueryRow(ctx context.Context, sql string, args ...any) pgx.Row
}

type tx struct {
	*pgx.Conn
}

func NewTx(conn *pgx.Conn) *tx {
	return &tx{Conn: conn}
}

const globalPgTx = "global_pg_tx"

func (t *tx) ExtractTx(ctx context.Context) Conn {
	pgTx, ok := ctx.Value(globalPgTx).(pgx.Tx)
	if ok {
		return pgTx
	}
	return &tx{Conn: t.Conn}
}

func (t *tx) BeginTx(ctx context.Context) (context.Context, error) {
	pgTx, err := t.Conn.Begin(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "error starting new transaction")
	}

	return context.WithValue(ctx, globalPgTx, pgTx), nil
}

func (t *tx) Rollback(ctx context.Context) error {
	pgTx, ok := ctx.Value(globalPgTx).(pgx.Tx)
	if ok {
		return pgTx.Rollback(ctx)
	}

	return nil
}

func (t *tx) Commit(ctx context.Context) error {
	pgTx, ok := ctx.Value(globalPgTx).(pgx.Tx)
	if ok {
		return pgTx.Commit(ctx)
	}

	return nil
}
