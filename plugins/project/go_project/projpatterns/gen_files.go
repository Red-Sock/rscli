package projpatterns

import (
	_ "embed"
	"reflect"
	"strings"
	"text/template"

	errors "github.com/Red-Sock/trace-errors"
	"github.com/godverv/matreshka"
	"github.com/godverv/matreshka/resources"

	"github.com/Red-Sock/rscli/internal/rw"
	"github.com/Red-Sock/rscli/internal/utils/cases"
	"github.com/Red-Sock/rscli/plugins/project/config"
)

const defaultGenTag = "// Code generated by RedSock CLI. DO NOT EDIT."

var (
	//go:embed pattern_c/internal/config/config_struct.go.pattern
	structPattern string

	//go:embed pattern_c/internal/clients/grpc/grpc_client.go.pattern
	grpcConnectionPattern string

	//go:embed pattern_c/internal/app/app.go.pattern
	appPattern string
)

var (
	configStructTemplate   *template.Template
	grpcConnectionTemplate *template.Template
	appTemplate            *template.Template
)

func init() {
	configStructTemplate = template.Must(
		template.New("environment").
			Parse(structPattern))

	grpcConnectionTemplate = template.Must(
		template.New("grpc_connection").
			Parse(grpcConnectionPattern))

	appTemplate = template.Must(
		template.New("app").
			Parse(appPattern))
}

type KeyValue struct {
	Key   string
	Value string
}

type structArgs struct {
	GenTag string

	StructName string
	Imports    map[string]string // path to alias
	Fields     []KeyValue
}

func newConfigStructGenArgs(structName string) structArgs {
	return structArgs{
		GenTag:     defaultGenTag,
		StructName: structName,
		Imports:    map[string]string{},
		Fields:     nil,
	}
}

func GenerateEnvironmentConfigStruct(environment matreshka.Environment) ([]byte, error) {
	ecg := newConfigStructGenArgs("EnvironmentConfig")

	for _, env := range environment {
		var fieldKV KeyValue
		fieldKV.Key = normalizeResourceName(env.Name)

		refVal := reflect.ValueOf(env.Value)
		tp := refVal.Type()

		fieldKV.Value = tp.String()

		if tp.PkgPath() != "" {
			ecg.Imports[tp.PkgPath()] = "" // todo think about aliases?
		}

		ecg.Fields = append(ecg.Fields, fieldKV)

	}

	buf := &rw.RW{}
	err := configStructTemplate.Execute(buf, ecg)
	if err != nil {
		return nil, errors.Wrap(err, "error executing template")
	}

	return buf.Bytes(), nil
}

func GenerateDataSourcesConfigStruct(dataSources matreshka.DataSources) ([]byte, error) {
	ecg := newConfigStructGenArgs("DataSourcesConfig")

	nameReplacer := strings.NewReplacer(
		" ", "_",
		"-", "_")

	normalizeName := func(s string) string {
		s = nameReplacer.Replace(s)
		s = cases.SnakeToPascal(s)
		return s
	}

	for _, ds := range dataSources {
		var fieldKV KeyValue
		fieldKV.Key = normalizeName(ds.GetName())

		refVal := reflect.ValueOf(ds)
		tp := refVal.Type()

		fieldKV.Value = tp.String()

		kind := tp.Kind()
		if kind == reflect.Ptr {
			tp = tp.Elem()
		}

		if tp.PkgPath() != "" {
			ecg.Imports[tp.PkgPath()] = "" // todo think about aliases?
		}

		ecg.Fields = append(ecg.Fields, fieldKV)

	}

	buf := &rw.RW{}
	err := configStructTemplate.Execute(buf, ecg)
	if err != nil {
		return nil, errors.Wrap(err, "error executing template")
	}

	return buf.Bytes(), nil
}

type GrpcClientArgs struct {
	ApiPackage  string
	Constructor string
	ClientName  string
}

func GenerateGRPCClient(args GrpcClientArgs) ([]byte, error) {
	buf := &rw.RW{}
	err := grpcConnectionTemplate.Execute(buf, args)
	if err != nil {
		return nil, errors.Wrap(err, "error executing template")
	}

	return buf.Bytes(), nil
}

type AppFileGenArgs struct {
	AppContent []AppContent
	Starters   []AppStarter
}

type AppContent struct {
	Comment              string
	Fields               []KeyValue
	InitFunc             string
	InitFuncErrorMessage string
}

type AppStarter struct {
	StartCall string
	StopCall  string
}

func GenerateAppFile(cfg *config.Config) ([]byte, error) {
	appArgs := AppFileGenArgs{}

	if len(cfg.DataSources) != 0 {
		fields := make([]KeyValue, 0, len(cfg.DataSources))
		for _, ds := range cfg.DataSources {

			kv := KeyValue{
				Key:   normalizeResourceName(ds.GetName()),
				Value: "",
			}
			switch ds.GetType() {
			case resources.PostgresResourceName:
				kv.Value = "*sql.Db"
			}
			fields = append(fields, kv)
		}
		appArgs.AppContent = append(appArgs.AppContent, AppContent{
			Comment:              "/* DataSource connections */",
			Fields:               fields,
			InitFunc:             "InitDataSources",
			InitFuncErrorMessage: "error during data source initialization",
		})
	}

	buf := &rw.RW{}
	err := appTemplate.Execute(buf, appArgs)
	if err != nil {
		return nil, errors.Wrap(err, "error generating app file")
	}

	return buf.Bytes(), nil
}

var nameReplacer = strings.NewReplacer(
	" ", "_",
	"-", "_")

func normalizeResourceName(in string) string {
	in = nameReplacer.Replace(in)
	return cases.SnakeToPascal(in)
}
